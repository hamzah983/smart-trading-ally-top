
// Follow this setup guide to integrate the Deno runtime into your application:
// https://deno.land/manual/getting_started/setup_your_environment
// This entrypoint file overwrites the main.ts entrypoint generated by supabase functions new binance-api

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

async function handler(req: Request) {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    // Get secret environment variables
    const SUPABASE_URL = Deno.env.get('SUPABASE_URL') || ''
    const SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY') || ''
    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || ''

    // Create Supabase client
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

    // Parse the request body
    const { action, accountId, data } = await req.json()
    console.log(`Received ${action} request for account ${accountId}`)

    // Get the trading account information
    const { data: accountData, error: accountError } = await supabase
      .from('trading_accounts')
      .select('api_key, api_secret, platform')
      .eq('id', accountId)
      .single()

    if (accountError) {
      throw new Error(`Error fetching account: ${accountError.message}`)
    }

    if (!accountData.api_key || !accountData.api_secret) {
      throw new Error('API credentials are not configured for this account')
    }

    // Create the Binance client with the API credentials
    const apiKey = accountData.api_key
    const apiSecret = accountData.api_secret

    // Different actions based on the request
    switch (action) {
      case 'test_connection':
        // Test the API connection
        const testResult = await testBinanceConnection(apiKey, apiSecret)
        return new Response(JSON.stringify(testResult), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })

      case 'place_order':
        // Place a new order
        if (!data.symbol || !data.side || !data.type || !data.quantity) {
          throw new Error('Missing required order parameters')
        }
        
        const orderResult = await placeBinanceOrder(
          apiKey, 
          apiSecret, 
          data.symbol,
          data.side,
          data.type,
          data.quantity,
          data.price
        )
        
        // Log the trade in the database
        if (orderResult.orderId) {
          const { error: tradeError } = await supabase
            .from('trades')
            .insert({
              account_id: accountId,
              symbol: data.symbol,
              type: data.side.toLowerCase(),
              entry_price: data.price || orderResult.price,
              lot_size: parseFloat(data.quantity),
              status: 'open',
              stop_loss: data.stopLoss,
              take_profit: data.takeProfit
            })
            
          if (tradeError) {
            console.error('Error logging trade:', tradeError)
          }
        }
        
        return new Response(JSON.stringify(orderResult), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })

      case 'get_account_info':
        // Get account balance and positions
        const accountInfo = await getBinanceAccountInfo(apiKey, apiSecret)
        
        // Update account balance in the database
        if (accountInfo.totalBalance) {
          const { error: updateError } = await supabase
            .from('trading_accounts')
            .update({
              balance: accountInfo.totalBalance,
              equity: accountInfo.totalEquity,
              last_sync_time: new Date().toISOString(),
              connection_status: true
            })
            .eq('id', accountId)
            
          if (updateError) {
            console.error('Error updating account balance:', updateError)
          }
        }
        
        return new Response(JSON.stringify(accountInfo), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })

      case 'close_position':
        // Close an existing position
        if (!data.symbol || !data.orderId) {
          throw new Error('Missing required parameters to close position')
        }
        
        const closeResult = await closeBinancePosition(
          apiKey, 
          apiSecret, 
          data.symbol,
          data.orderId,
          data.quantity
        )
        
        // Update trade status in the database
        if (closeResult.success && data.tradeId) {
          const { error: updateTradeError } = await supabase
            .from('trades')
            .update({
              status: 'closed',
              closed_at: new Date().toISOString(),
              pnl: data.pnl || 0
            })
            .eq('id', data.tradeId)
            
          if (updateTradeError) {
            console.error('Error updating trade status:', updateTradeError)
          }
        }
        
        return new Response(JSON.stringify(closeResult), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })

      case 'update_stop_loss':
        // Update stop loss for an existing position
        if (!data.symbol || !data.orderId || !data.stopPrice) {
          throw new Error('Missing required parameters to update stop loss')
        }
        
        const slResult = await updateBinanceStopLoss(
          apiKey, 
          apiSecret, 
          data.symbol,
          data.orderId,
          data.stopPrice
        )
        
        // Update trade in the database
        if (slResult.success && data.tradeId) {
          const { error: updateSlError } = await supabase
            .from('trades')
            .update({
              stop_loss: data.stopPrice
            })
            .eq('id', data.tradeId)
            
          if (updateSlError) {
            console.error('Error updating stop loss in database:', updateSlError)
          }
        }
        
        return new Response(JSON.stringify(slResult), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })

      default:
        throw new Error(`Unknown action: ${action}`)
    }
  } catch (error) {
    console.error(`Error processing request:`, error.message)
    return new Response(JSON.stringify({ error: error.message }), {
      status: 400,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })
  }
}

// Function to test Binance API connection
async function testBinanceConnection(apiKey: string, apiSecret: string) {
  try {
    const timestamp = Date.now()
    const signature = await createSignature(`timestamp=${timestamp}`, apiSecret)
    
    const response = await fetch(`https://api.binance.com/api/v3/account?timestamp=${timestamp}&signature=${signature}`, {
      method: 'GET',
      headers: {
        'X-MBX-APIKEY': apiKey,
      },
    })
    
    if (!response.ok) {
      const errorData = await response.json()
      return { success: false, message: errorData.msg || 'Connection failed' }
    }
    
    return { success: true, message: 'Connection successful' }
  } catch (error) {
    return { success: false, message: error.message }
  }
}

// Function to place an order on Binance
async function placeBinanceOrder(
  apiKey: string, 
  apiSecret: string, 
  symbol: string,
  side: string, 
  type: string,
  quantity: string,
  price?: string
) {
  try {
    const timestamp = Date.now()
    
    let queryString = `symbol=${symbol}&side=${side}&type=${type}&quantity=${quantity}&timestamp=${timestamp}`
    
    // Add price for limit orders
    if (type === 'LIMIT' && price) {
      queryString += `&price=${price}&timeInForce=GTC`
    }
    
    const signature = await createSignature(queryString, apiSecret)
    queryString += `&signature=${signature}`
    
    const response = await fetch(`https://api.binance.com/api/v3/order?${queryString}`, {
      method: 'POST',
      headers: {
        'X-MBX-APIKEY': apiKey,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    })
    
    if (!response.ok) {
      const errorData = await response.json()
      return { success: false, message: errorData.msg || 'Order placement failed' }
    }
    
    const orderData = await response.json()
    return { 
      success: true, 
      orderId: orderData.orderId,
      price: orderData.price,
      executedQty: orderData.executedQty,
      message: 'Order placed successfully' 
    }
  } catch (error) {
    return { success: false, message: error.message }
  }
}

// Function to get account information from Binance
async function getBinanceAccountInfo(apiKey: string, apiSecret: string) {
  try {
    const timestamp = Date.now()
    const signature = await createSignature(`timestamp=${timestamp}`, apiSecret)
    
    const response = await fetch(`https://api.binance.com/api/v3/account?timestamp=${timestamp}&signature=${signature}`, {
      method: 'GET',
      headers: {
        'X-MBX-APIKEY': apiKey,
      },
    })
    
    if (!response.ok) {
      const errorData = await response.json()
      return { success: false, message: errorData.msg || 'Failed to get account info' }
    }
    
    const accountData = await response.json()
    
    // Calculate total balance
    let totalBalance = 0
    let totalEquity = 0
    
    if (accountData.balances) {
      // Get latest prices for all assets 
      const priceListResponse = await fetch('https://api.binance.com/api/v3/ticker/price')
      const priceList = await priceListResponse.json()
      const prices = priceList.reduce((acc: any, item: any) => {
        acc[item.symbol] = parseFloat(item.price)
        return acc
      }, {})
      
      // Sum up the balances
      for (const balance of accountData.balances) {
        const free = parseFloat(balance.free)
        const locked = parseFloat(balance.locked)
        const total = free + locked
        
        if (total > 0) {
          if (balance.asset === 'USDT') {
            totalBalance += total
            totalEquity += total
          } else {
            // Try to find a price for this asset in USDT
            const symbol = `${balance.asset}USDT`
            if (prices[symbol]) {
              const usdtValue = total * prices[symbol]
              totalEquity += usdtValue
            }
          }
        }
      }
    }
    
    return {
      success: true,
      totalBalance,
      totalEquity,
      balances: accountData.balances.filter((b: any) => parseFloat(b.free) > 0 || parseFloat(b.locked) > 0),
      positions: accountData.positions || []
    }
  } catch (error) {
    return { success: false, message: error.message }
  }
}

// Function to close a position on Binance
async function closeBinancePosition(
  apiKey: string, 
  apiSecret: string, 
  symbol: string,
  orderId: string,
  quantity: string
) {
  try {
    // First, get the position side
    const posResponse = await fetch(`https://api.binance.com/api/v3/openOrders`, {
      method: 'GET',
      headers: {
        'X-MBX-APIKEY': apiKey,
      },
    })
    
    if (!posResponse.ok) {
      const errorData = await posResponse.json()
      return { success: false, message: errorData.msg || 'Failed to get position info' }
    }
    
    // Determine the side for closing (opposite of the opening side)
    // If original position was BUY, we need to SELL to close it
    const side = 'SELL' // Simplified version. In a real implementation, look up the original side
    
    const timestamp = Date.now()
    let queryString = `symbol=${symbol}&side=${side}&type=MARKET&quantity=${quantity}&timestamp=${timestamp}`
    
    const signature = await createSignature(queryString, apiSecret)
    queryString += `&signature=${signature}`
    
    const response = await fetch(`https://api.binance.com/api/v3/order?${queryString}`, {
      method: 'POST',
      headers: {
        'X-MBX-APIKEY': apiKey,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    })
    
    if (!response.ok) {
      const errorData = await response.json()
      return { success: false, message: errorData.msg || 'Failed to close position' }
    }
    
    const closeData = await response.json()
    return { 
      success: true, 
      closingOrderId: closeData.orderId,
      price: closeData.price,
      executedQty: closeData.executedQty,
      message: 'Position closed successfully' 
    }
  } catch (error) {
    return { success: false, message: error.message }
  }
}

// Function to update stop loss for a position
async function updateBinanceStopLoss(
  apiKey: string, 
  apiSecret: string, 
  symbol: string,
  orderId: string,
  stopPrice: string
) {
  try {
    // Cancel any existing stop loss first
    const cancelResponse = await cancelExistingStopLoss(apiKey, apiSecret, symbol, orderId)
    
    // Place new stop loss order
    const timestamp = Date.now()
    let queryString = `symbol=${symbol}&side=SELL&type=STOP_LOSS_LIMIT&price=${stopPrice}&stopPrice=${stopPrice}&quantity=1&timeInForce=GTC&timestamp=${timestamp}`
    
    const signature = await createSignature(queryString, apiSecret)
    queryString += `&signature=${signature}`
    
    const response = await fetch(`https://api.binance.com/api/v3/order?${queryString}`, {
      method: 'POST',
      headers: {
        'X-MBX-APIKEY': apiKey,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    })
    
    if (!response.ok) {
      const errorData = await response.json()
      return { success: false, message: errorData.msg || 'Failed to update stop loss' }
    }
    
    const slData = await response.json()
    return { 
      success: true, 
      stopLossOrderId: slData.orderId,
      message: 'Stop loss updated successfully' 
    }
  } catch (error) {
    return { success: false, message: error.message }
  }
}

// Helper function to cancel existing stop loss
async function cancelExistingStopLoss(apiKey: string, apiSecret: string, symbol: string, orderId: string) {
  try {
    const timestamp = Date.now()
    let queryString = `symbol=${symbol}&timestamp=${timestamp}`
    
    const signature = await createSignature(queryString, apiSecret)
    queryString += `&signature=${signature}`
    
    // Get all open orders for the symbol
    const ordersResponse = await fetch(`https://api.binance.com/api/v3/openOrders?${queryString}`, {
      method: 'GET',
      headers: {
        'X-MBX-APIKEY': apiKey,
      },
    })
    
    if (!ordersResponse.ok) {
      return { success: false, message: 'Failed to fetch open orders' }
    }
    
    const orders = await ordersResponse.json()
    
    // Find stop loss orders related to our position
    const stopLossOrders = orders.filter((o: any) => 
      o.symbol === symbol && 
      (o.type === 'STOP_LOSS' || o.type === 'STOP_LOSS_LIMIT')
    )
    
    // Cancel them if found
    for (const order of stopLossOrders) {
      const cancelTimestamp = Date.now()
      const cancelQueryString = `symbol=${symbol}&orderId=${order.orderId}&timestamp=${cancelTimestamp}`
      const cancelSignature = await createSignature(cancelQueryString, apiSecret)
      
      await fetch(`https://api.binance.com/api/v3/order?${cancelQueryString}&signature=${cancelSignature}`, {
        method: 'DELETE',
        headers: {
          'X-MBX-APIKEY': apiKey,
        },
      })
    }
    
    return { success: true }
  } catch (error) {
    return { success: false, message: error.message }
  }
}

// Helper function to create HMAC SHA256 signature for Binance API authentication
async function createSignature(queryString: string, apiSecret: string): Promise<string> {
  const encoder = new TextEncoder()
  const key = encoder.encode(apiSecret)
  const message = encoder.encode(queryString)
  
  const cryptoKey = await crypto.subtle.importKey(
    'raw',
    key,
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  )
  
  const signature = await crypto.subtle.sign('HMAC', cryptoKey, message)
  
  return Array.from(new Uint8Array(signature))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')
}

serve(handler)
