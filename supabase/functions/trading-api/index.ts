
// Follow this setup guide to integrate the Deno runtime into your application:
// https://deno.land/manual/getting_started/setup_your_environment
// This entrypoint file overwrites the main.ts entrypoint generated by supabase functions new trading-api

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

async function handler(req: Request) {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    // Get secret environment variables
    const SUPABASE_URL = Deno.env.get('SUPABASE_URL') || ''
    const SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY') || ''
    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || ''

    // Create Supabase client
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

    // Parse the request body
    const { action, botId, accountId, userId } = await req.json()
    console.log(`Received ${action} request for bot ${botId}`)

    switch(action) {
      case 'start_bot':
        if (!botId) {
          throw new Error('Bot ID is required')
        }
        
        // Get bot configuration
        const { data: botData, error: botError } = await supabase
          .from('trading_bots')
          .select('*, account_id')
          .eq('id', botId)
          .single()
          
        if (botError) {
          throw new Error(`Error fetching bot: ${botError.message}`)
        }
        
        // Log bot activation
        await supabase.from('trading_logs').insert({
          bot_id: botId,
          account_id: botData.account_id,
          log_type: 'info',
          message: 'Bot activated',
          details: { action: 'start', timestamp: new Date().toISOString() }
        })
        
        // Update bot status
        await supabase
          .from('trading_bots')
          .update({ is_active: true })
          .eq('id', botId)
        
        // Start the bot process (in a real implementation, this would create a background process)
        const botProcess = startTradingBot(botId, botData.account_id, supabase)
        
        return new Response(JSON.stringify({ 
          success: true, 
          message: 'Bot started successfully',
          bot_id: botId
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      case 'stop_bot':
        if (!botId) {
          throw new Error('Bot ID is required')
        }
        
        // Get bot information
        const { data: stopBotData, error: stopBotError } = await supabase
          .from('trading_bots')
          .select('account_id')
          .eq('id', botId)
          .single()
          
        if (stopBotError) {
          throw new Error(`Error fetching bot: ${stopBotError.message}`)
        }
        
        // Log bot deactivation
        await supabase.from('trading_logs').insert({
          bot_id: botId,
          account_id: stopBotData.account_id,
          log_type: 'info',
          message: 'Bot deactivated',
          details: { action: 'stop', timestamp: new Date().toISOString() }
        })
        
        // Update bot status
        await supabase
          .from('trading_bots')
          .update({ is_active: false })
          .eq('id', botId)
        
        return new Response(JSON.stringify({ 
          success: true, 
          message: 'Bot stopped successfully',
          bot_id: botId
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      case 'execute_trade':
        if (!accountId) {
          throw new Error('Account ID is required')
        }
        
        const { symbol, type, lotSize, stopLoss, takeProfit } = await req.json()
        
        if (!symbol || !type || !lotSize) {
          throw new Error('Missing required trade parameters')
        }
        
        // Get account information
        const { data: accountData, error: accountError } = await supabase
          .from('trading_accounts')
          .select('id, api_key, api_secret, platform')
          .eq('id', accountId)
          .single()
          
        if (accountError) {
          throw new Error(`Error fetching account: ${accountError.message}`)
        }
        
        if (!accountData.api_key || !accountData.api_secret) {
          throw new Error('API credentials are not configured for this account')
        }
        
        // Execute trade through Binance API
        const tradeResult = await executeTrade(
          accountData.api_key,
          accountData.api_secret,
          symbol,
          type,
          lotSize,
          stopLoss,
          takeProfit,
          accountId,
          supabase
        )
        
        return new Response(JSON.stringify(tradeResult), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      case 'get_bot_status':
        if (!botId) {
          throw new Error('Bot ID is required')
        }
        
        // Get bot status and performance metrics
        const { data: statusData, error: statusError } = await supabase
          .from('trading_bots')
          .select('is_active, performance_metrics, settings')
          .eq('id', botId)
          .single()
          
        if (statusError) {
          throw new Error(`Error fetching bot status: ${statusError.message}`)
        }
        
        // Get recent trades by this bot
        const { data: botTrades, error: tradesError } = await supabase
          .from('trades')
          .select('id, symbol, type, entry_price, pnl, created_at, status')
          .eq('bot_id', botId)
          .order('created_at', { ascending: false })
          .limit(5)
          
        if (tradesError) {
          console.error(`Error fetching bot trades: ${tradesError.message}`)
        }
        
        // Get recent logs for this bot
        const { data: botLogs, error: logsError } = await supabase
          .from('trading_logs')
          .select('id, message, log_type, created_at, details')
          .eq('bot_id', botId)
          .order('created_at', { ascending: false })
          .limit(10)
          
        if (logsError) {
          console.error(`Error fetching bot logs: ${logsError.message}`)
        }
        
        return new Response(JSON.stringify({ 
          success: true, 
          bot_status: statusData.is_active,
          performance: statusData.performance_metrics,
          settings: statusData.settings,
          recent_trades: botTrades || [],
          logs: botLogs || []
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      default:
        throw new Error(`Unknown action: ${action}`)
    }
  } catch (error) {
    console.error(`Error processing request:`, error.message)
    return new Response(JSON.stringify({ error: error.message }), {
      status: 400,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })
  }
}

// Function to start the trading bot
async function startTradingBot(botId: string, accountId: string, supabase: any) {
  try {
    // In a real implementation, this would be a long-running process
    // For demo purposes, we'll just log the bot start
    console.log(`Starting trading bot ${botId} for account ${accountId}`)
    
    // Get bot settings
    const { data: botData, error: botError } = await supabase
      .from('trading_bots')
      .select('strategy_type, settings, risk_parameters')
      .eq('id', botId)
      .single()
      
    if (botError) {
      throw new Error(`Error fetching bot settings: ${botError.message}`)
    }
    
    // Log bot settings
    await supabase.from('trading_logs').insert({
      bot_id: botId,
      account_id: accountId,
      log_type: 'info',
      message: 'Bot startup configuration',
      details: { 
        strategy: botData.strategy_type,
        settings: botData.settings,
        risk: botData.risk_parameters
      }
    })
    
    // In a real implementation, you would set up market monitoring and trading logic here
    // For this demo, we'll simulate a trade after a delay
    
    // Simulate market analysis and trading decision
    setTimeout(async () => {
      if (botData.strategy_type === 'trend_following') {
        // Simulate trend analysis
        await supabase.from('trading_logs').insert({
          bot_id: botId,
          account_id: accountId,
          log_type: 'info',
          message: 'Market analysis completed',
          details: { 
            trend: 'bullish',
            indicators: {
              rsi: 65,
              macd: 'positive',
              volume: 'increasing'
            }
          }
        })
        
        // Simulate placing a trade
        const symbol = 'BTCUSDT'
        const tradeType = 'buy'
        const lotSize = 0.001 // Small BTC amount
        
        // Execute trade through API
        try {
          await executeTrade(
            'API_KEY', // This would be fetched from the account in a real implementation
            'API_SECRET',
            symbol,
            tradeType,
            lotSize,
            null,
            null,
            accountId,
            supabase,
            botId
          )
        } catch (error) {
          await supabase.from('trading_logs').insert({
            bot_id: botId,
            account_id: accountId,
            log_type: 'error',
            message: 'Failed to execute trade',
            details: { error: error.message }
          })
        }
      }
    }, 5000)
    
    return { success: true }
  } catch (error) {
    console.error(`Error starting bot:`, error.message)
    return { success: false, error: error.message }
  }
}

// Function to execute a trade
async function executeTrade(
  apiKey: string,
  apiSecret: string,
  symbol: string,
  type: string,
  lotSize: number,
  stopLoss: number | null,
  takeProfit: number | null,
  accountId: string,
  supabase: any,
  botId?: string
) {
  try {
    // Log the trade attempt
    await supabase.from('trading_logs').insert({
      bot_id: botId,
      account_id: accountId,
      log_type: 'info',
      message: `Executing ${type} order for ${symbol}`,
      details: { 
        symbol,
        type,
        lot_size: lotSize,
        stop_loss: stopLoss,
        take_profit: takeProfit,
        timestamp: new Date().toISOString()
      }
    })
    
    // In a real implementation, this would call the Binance API
    // For this demo, we'll simulate a successful order
    
    // Get current price for the symbol (simulated)
    const currentPrice = await getSimulatedPrice(symbol)
    
    // Create a new trade record
    const { data: tradeData, error: tradeError } = await supabase
      .from('trades')
      .insert({
        account_id: accountId,
        bot_id: botId,
        symbol,
        type,
        entry_price: currentPrice,
        lot_size: lotSize,
        stop_loss: stopLoss,
        take_profit: takeProfit,
        status: 'open'
      })
      .select()
      
    if (tradeError) {
      throw new Error(`Error recording trade: ${tradeError.message}`)
    }
    
    // Log successful trade
    await supabase.from('trading_logs').insert({
      bot_id: botId,
      account_id: accountId,
      log_type: 'success',
      message: `Successfully placed ${type} order for ${symbol}`,
      details: { 
        trade_id: tradeData[0].id,
        price: currentPrice,
        timestamp: new Date().toISOString()
      }
    })
    
    return { 
      success: true, 
      trade_id: tradeData[0].id,
      message: `Successfully executed ${type} order for ${symbol} at price ${currentPrice}`,
      price: currentPrice
    }
  } catch (error) {
    console.error(`Error executing trade:`, error.message)
    return { success: false, error: error.message }
  }
}

// Helper function to get simulated price
async function getSimulatedPrice(symbol: string): Promise<number> {
  try {
    // In a real implementation, this would fetch the current market price
    // For demo purposes, we'll use mock prices
    const mockPrices: Record<string, number> = {
      'BTCUSDT': 29850.75,
      'ETHUSDT': 1865.25,
      'BNBUSDT': 221.45,
      'XRPUSDT': 0.52,
      'ADAUSDT': 0.35,
      'DOGEUSDT': 0.078,
      'SOLUSDT': 140.25
    }
    
    return mockPrices[symbol] || 100.0
  } catch (error) {
    console.error(`Error getting price:`, error)
    return 100.0 // Default fallback price
  }
}

serve(handler)
