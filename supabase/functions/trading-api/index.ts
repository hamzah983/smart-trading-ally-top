// Follow this setup guide to integrate the Deno runtime into your application:
// https://deno.land/manual/getting_started/setup_your_environment
// This entrypoint file overwrites the main.ts entrypoint generated by supabase functions new trading-api

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

async function handler(req: Request) {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    // Get secret environment variables
    const SUPABASE_URL = Deno.env.get('SUPABASE_URL') || ''
    const SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY') || ''
    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || ''

    // Create Supabase client
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

    // Parse the request body
    const { action, botId, accountId, userId } = await req.json()
    console.log(`Received ${action} request for bot ${botId}`)

    switch(action) {
      case 'start_bot':
        if (!botId) {
          throw new Error('Bot ID is required')
        }
        
        // Get bot configuration
        const { data: botData, error: botError } = await supabase
          .from('trading_bots')
          .select('*, account_id, auto_management, auto_settings, multi_strategy, strategies_rotation, trading_pairs')
          .eq('id', botId)
          .single()
          
        if (botError) {
          throw new Error(`Error fetching bot: ${botError.message}`)
        }
        
        // Log bot activation
        await supabase.from('trading_logs').insert({
          bot_id: botId,
          account_id: botData.account_id,
          log_type: 'info',
          message: 'Bot activated',
          details: { 
            action: 'start', 
            timestamp: new Date().toISOString(),
            server_managed: true, // Flag indicating the bot is managed by the server
            auto_management: botData.auto_management,
            multi_strategy: botData.multi_strategy
          }
        })
        
        // Update bot status
        await supabase
          .from('trading_bots')
          .update({ 
            is_active: true,
            last_activity: new Date().toISOString(), 
            server_status: 'running' 
          })
          .eq('id', botId)
        
        // Start the bot process in the background (this function persists on the server)
        const botProcess = startTradingBot(botId, botData.account_id, supabase, botData)
        
        return new Response(JSON.stringify({ 
          success: true, 
          message: 'الروبوت يعمل الآن على الخادم وسيستمر حتى بعد إغلاق التطبيق',
          bot_id: botId,
          server_managed: true,
          auto_managed: botData.auto_management || false
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      case 'stop_bot':
        if (!botId) {
          throw new Error('Bot ID is required')
        }
        
        // Get bot information
        const { data: stopBotData, error: stopBotError } = await supabase
          .from('trading_bots')
          .select('account_id')
          .eq('id', botId)
          .single()
          
        if (stopBotError) {
          throw new Error(`Error fetching bot: ${stopBotError.message}`)
        }
        
        // Log bot deactivation
        await supabase.from('trading_logs').insert({
          bot_id: botId,
          account_id: stopBotData.account_id,
          log_type: 'info',
          message: 'Bot deactivated',
          details: { action: 'stop', timestamp: new Date().toISOString() }
        })
        
        // Update bot status
        await supabase
          .from('trading_bots')
          .update({ 
            is_active: false,
            server_status: 'stopped',
            last_activity: new Date().toISOString()
          })
          .eq('id', botId)
        
        return new Response(JSON.stringify({ 
          success: true, 
          message: 'تم إيقاف الروبوت بنجاح',
          bot_id: botId
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      case 'execute_trade':
        if (!accountId) {
          throw new Error('Account ID is required')
        }
        
        const { symbol, type, lotSize, stopLoss, takeProfit } = await req.json()
        
        if (!symbol || !type || !lotSize) {
          throw new Error('Missing required trade parameters')
        }
        
        // Get account information
        const { data: accountData, error: accountError } = await supabase
          .from('trading_accounts')
          .select('id, api_key, api_secret, platform')
          .eq('id', accountId)
          .single()
          
        if (accountError) {
          throw new Error(`Error fetching account: ${accountError.message}`)
        }
        
        if (!accountData.api_key || !accountData.api_secret) {
          throw new Error('API credentials are not configured for this account')
        }
        
        // Execute trade through Binance API
        const tradeResult = await executeTrade(
          accountData.api_key,
          accountData.api_secret,
          symbol,
          type,
          lotSize,
          stopLoss,
          takeProfit,
          accountId,
          supabase
        )
        
        return new Response(JSON.stringify(tradeResult), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      case 'get_bot_status':
        if (!botId) {
          throw new Error('Bot ID is required')
        }
        
        // Get bot status and performance metrics
        const { data: statusData, error: statusError } = await supabase
          .from('trading_bots')
          .select('is_active, performance_metrics, settings, server_status, last_activity')
          .eq('id', botId)
          .single()
          
        if (statusError) {
          throw new Error(`Error fetching bot status: ${statusError.message}`)
        }
        
        // Get recent trades by this bot
        const { data: botTrades, error: tradesError } = await supabase
          .from('trades')
          .select('id, symbol, type, entry_price, pnl, created_at, status')
          .eq('bot_id', botId)
          .order('created_at', { ascending: false })
          .limit(5)
          
        if (tradesError) {
          console.error(`Error fetching bot trades: ${tradesError.message}`)
        }
        
        // Get recent logs for this bot
        const { data: botLogs, error: logsError } = await supabase
          .from('trading_logs')
          .select('id, message, log_type, created_at, details')
          .eq('bot_id', botId)
          .order('created_at', { ascending: false })
          .limit(10)
          
        if (logsError) {
          console.error(`Error fetching bot logs: ${logsError.message}`)
        }
        
        // Calculate bot uptime if it's running
        let uptimeInfo = null
        if (statusData.server_status === 'running' && statusData.last_activity) {
          const lastActivity = new Date(statusData.last_activity);
          const now = new Date();
          const uptimeMs = now.getTime() - lastActivity.getTime();
          
          // Format uptime in hours and minutes
          const uptimeHours = Math.floor(uptimeMs / (1000 * 60 * 60));
          const uptimeMinutes = Math.floor((uptimeMs % (1000 * 60 * 60)) / (1000 * 60));
          
          uptimeInfo = {
            hours: uptimeHours,
            minutes: uptimeMinutes,
            formatted: `${uptimeHours} ساعة و ${uptimeMinutes} دقيقة`
          };
        }
        
        return new Response(JSON.stringify({ 
          success: true, 
          bot_status: statusData.is_active,
          server_status: statusData.server_status || 'unknown',
          uptime: uptimeInfo,
          performance: statusData.performance_metrics,
          settings: statusData.settings,
          last_activity: statusData.last_activity,
          recent_trades: botTrades || [],
          logs: botLogs || []
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      case 'check_server_status':
        // New endpoint to verify server operation and check all running bots
        
        // Get all active bots
        const { data: activeBots, error: activeBotsError } = await supabase
          .from('trading_bots')
          .select('id, name, account_id, is_active, server_status, last_activity')
          .eq('is_active', true)
        
        if (activeBotsError) {
          throw new Error(`Error fetching active bots: ${activeBotsError.message}`)
        }
        
        // Update last heartbeat for each bot
        for (const bot of activeBots || []) {
          if (bot.server_status === 'running') {
            // Update last activity timestamp
            await supabase
              .from('trading_bots')
              .update({ 
                last_activity: new Date().toISOString()
              })
              .eq('id', bot.id)
              
            // Add heartbeat log
            await supabase.from('trading_logs').insert({
              bot_id: bot.id,
              account_id: bot.account_id,
              log_type: 'info',
              message: 'Server heartbeat',
              details: { 
                action: 'heartbeat', 
                timestamp: new Date().toISOString()
              }
            })
          }
        }
        
        return new Response(JSON.stringify({ 
          success: true, 
          server_status: 'online',
          active_bots: activeBots?.length || 0,
          message: 'الخادم يعمل بشكل طبيعي ويدير الروبوتات النشطة'
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      case 'analyze_market_conditions':
        // إضافة تحليل ظروف السوق للروبوتات الذكية
        if (!botId) {
          throw new Error('Bot ID is required')
        }
        
        // احصل على بيانات الروبوت
        const { data: smartBotData, error: smartBotError } = await supabase
          .from('trading_bots')
          .select('*, account_id, auto_management, auto_settings, trading_pairs, strategies_rotation')
          .eq('id', botId)
          .single()
          
        if (smartBotError) {
          throw new Error(`Error fetching bot: ${smartBotError.message}`)
        }
        
        if (!smartBotData.auto_management) {
          throw new Error('This bot is not configured for auto management')
        }
        
        // تحليل ظروف السوق لكل زوج تداول
        const marketAnalysis = await analyzeMarketConditions(
          smartBotData.trading_pairs || [smartBotData.trading_pair], 
          smartBotData.strategies_rotation?.strategies || [smartBotData.strategy_type]
        )
        
        // سجل نتائج التحليل
        await supabase.from('trading_logs').insert({
          bot_id: botId,
          account_id: smartBotData.account_id,
          log_type: 'info',
          message: 'تحليل ظروف السوق للروبوت الذكي',
          details: { 
            market_analysis: marketAnalysis,
            timestamp: new Date().toISOString()
          }
        })
        
        return new Response(JSON.stringify({ 
          success: true, 
          market_analysis: marketAnalysis
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      case 'recommend_strategy':
        // اقتراح أفضل استراتيجية بناءً على ظروف السوق
        if (!botId) {
          throw new Error('Bot ID is required')
        }
        
        // احصل على بيانات الروبوت
        const { data: strategyBotData, error: strategyBotError } = await supabase
          .from('trading_bots')
          .select('*, account_id, auto_settings, strategies_rotation')
          .eq('id', botId)
          .single()
          
        if (strategyBotError) {
          throw new Error(`Error fetching bot: ${strategyBotError.message}`)
        }
        
        if (!strategyBotData.multi_strategy) {
          throw new Error('This bot is not configured for multi-strategy')
        }
        
        // احصل على الاستراتيجيات المتاحة
        const availableStrategies = strategyBotData.strategies_rotation?.strategies || []
        if (availableStrategies.length === 0) {
          throw new Error('No strategies configured for this bot')
        }
        
        // اختر أفضل استراتيجية
        const recommendedStrategy = await recommendBestStrategy(
          availableStrategies, 
          strategyBotData.trading_pair,
          strategyBotData.risk_level
        )
        
        // سجل الاستراتيجية المقترحة
        await supabase.from('trading_logs').insert({
          bot_id: botId,
          account_id: strategyBotData.account_id,
          log_type: 'info',
          message: `تم اقتراح استراتيجية ${recommendedStrategy.strategy}`,
          details: recommendedStrategy
        })
        
        return new Response(JSON.stringify({ 
          success: true, 
          recommended_strategy: recommendedStrategy
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
        
      default:
        throw new Error(`Unknown action: ${action}`)
    }
  } catch (error) {
    console.error(`Error processing request:`, error.message)
    return new Response(JSON.stringify({ error: error.message }), {
      status: 400,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })
  }
}

// Function to start the trading bot with auto management support
async function startTradingBot(botId: string, accountId: string, supabase: any, botData: any = null) {
  try {
    // In a real production environment, this would be a long-running process
    // that continues to run on the server even after the user closes the app
    console.log(`Starting trading bot ${botId} for account ${accountId} on server`)
    
    // Get bot settings if not provided
    if (!botData) {
      const { data, error } = await supabase
        .from('trading_bots')
        .select('strategy_type, settings, risk_parameters, auto_management, auto_settings, trading_pairs, strategies_rotation')
        .eq('id', botId)
        .single()
        
      if (error) {
        throw new Error(`Error fetching bot settings: ${error.message}`)
      }
      
      botData = data
    }
    
    // تسجيل بداية تشغيل الروبوت
    const botTypeMessage = botData.auto_management 
      ? 'الروبوت الذكي يعمل الآن بالإدارة التلقائية وسيختار الاستراتيجيات المناسبة' 
      : 'الروبوت يعمل الآن على الخادم وسيستمر حتى بعد إغلاق التطبيق'
    
    await supabase.from('trading_logs').insert({
      bot_id: botId,
      account_id: accountId,
      log_type: 'info',
      message: botTypeMessage,
      details: { 
        strategy: botData.strategy_type,
        settings: botData.settings,
        risk: botData.risk_parameters,
        server_managed: true,
        auto_management: botData.auto_management || false,
        auto_settings: botData.auto_settings || null
      }
    })
    
    // استخراج أزواج التداول من البيانات
    const tradingPairs = botData.trading_pairs || [botData.trading_pair || 'BTCUSDT'];
    
    // Log that we're analyzing multiple pairs
    await supabase.from('trading_logs').insert({
      bot_id: botId,
      account_id: accountId,
      log_type: 'info',
      message: `بد�� تحليل ${tradingPairs.length} أزواج تداول`,
      details: { 
        pairs: tradingPairs,
        timestamp: new Date().toISOString()
      }
    });
    
    // خاص بالروبوتات الذكية ذات الإدارة التلقائية
    if (botData.auto_management) {
      // تنفيذ التحليل التلقائي واختيار الاستراتيجية
      setTimeout(async () => {
        try {
          // تحليل ظروف السوق
          const marketAnalysis = await analyzeMarketConditions(tradingPairs, 
            botData.strategies_rotation?.strategies || [botData.strategy_type]);
          
          // تسجيل نتائج التحليل
          await supabase.from('trading_logs').insert({
            bot_id: botId,
            account_id: accountId,
            log_type: 'info',
            message: 'تم تحليل ظروف السوق بواسطة الروبوت الذكي',
            details: { 
              market_analysis: marketAnalysis
            }
          });
          
          // اختيار الاستراتيجية المناسبة
          const bestPair = Object.keys(marketAnalysis).reduce((best, pair) => {
            return marketAnalysis[pair].score > marketAnalysis[best]?.score ? pair : best;
          }, Object.keys(marketAnalysis)[0]);
          
          // اختيار أفضل استراتيجية للتداول
          const recommendedStrategy = await recommendBestStrategy(
            botData.strategies_rotation?.strategies || [botData.strategy_type],
            bestPair,
            botData.risk_level
          );
          
          // تسجيل الاستراتيجية المختارة
          await supabase.from('trading_logs').insert({
            bot_id: botId,
            account_id: accountId,
            log_type: 'success',
            message: `تم اختيار استراتيجية ${recommendedStrategy.strategyName} للتداول على ${bestPair}`,
            details: { 
              strategy: recommendedStrategy,
              pair: bestPair
            }
          });
          
          // حساب حجم الصفقة المناسب بناءً على إعدادات الروبوت
          const { data: accountData } = await supabase
            .from('trading_accounts')
            .select('balance, equity, max_drawdown')
            .eq('id', accountId)
            .single();
          
          const balance = accountData?.equity || accountData?.balance || 1000;
          
          // حساب الحجم المناسب حسب مستوى المخاطرة
          const riskPercentage = botData.risk_level === 'low' ? 1 : 
                              botData.risk_level === 'medium' ? 2 : 5;
          
          const positionSize = calculatePositionSize(
            balance, 
            riskPercentage, 
            bestPair,
            botData.auto_settings?.smart_position_sizing || false
          );
          
          // تنفيذ الصفقة
          try {
            // في التطبيق الحقيقي، سنستخدم مفاتيح API الفعلية
            await executeTrade(
              'API_KEY', // هذه ستكون مفاتيح API الحقيقية في التطبيق الفعلي
              'API_SECRET',
              bestPair,
              recommendedStrategy.direction, // الاتجاه الموصى به (شراء/بيع)
              positionSize,
              null, // قيمة وقف الخسارة ستحسب تلقائيًا
              null, // قيمة جني الربح ستحسب تلقائيًا
              accountId,
              supabase,
              botId,
              true, // إشارة إلى أن هذه صفقة تلقائية
              recommendedStrategy.strategy
            );
            
            // تحديث إحصائيات الروبوت
            await supabase
              .from('trading_bots')
              .update({
                last_activity: new Date().toISOString(),
                // تحديث البيانات الإحصائية في التطبيق الحقيقي
              })
              .eq('id', botId);
              
          } catch (error) {
            await supabase.from('trading_logs').insert({
              bot_id: botId,
              account_id: accountId,
              log_type: 'error',
              message: 'فشل تنفيذ الصفقة التلقائية',
              details: { error: error.message }
            });
          }
          
          // في البيئة الحقيقية، سيستمر الروبوت في مراقبة السوق وتنفيذ المزيد من الصفقات
          
        } catch (error) {
          console.error("Error in smart trading bot:", error);
          await supabase.from('trading_logs').insert({
            bot_id: botId,
            account_id: accountId,
            log_type: 'error',
            message: 'خطأ في تشغيل الروبوت الذكي',
            details: { error: error.message }
          });
        }
      }, 5000);
    } 
    // الروبوت العادي (غير ذكي)
    else {
      // For demo purposes, simulate a trade after a delay
      // In a real system, this would happen based on actual market conditions
      setTimeout(async () => {
        // ... keep existing code (محاكاة التداول العادي)
      }, 5000);
    }
    
    return { success: true }
  } catch (error) {
    console.error(`Error starting bot:`, error.message)
    return { success: false, error: error.message }
  }
}

// Function to analyze market conditions
async function analyzeMarketConditions(pairs: string[], strategies: string[]) {
  try {
    // في بيئة حقيقية، هذه الدالة ستحلل بيانات السوق الفعلية
    // هنا نستخدم بيانات محاكاة للتوضيح
    
    const result: Record<string, any> = {};
    
    for (const pair of pairs) {
      // محاكاة تحليل الزوج
      const pairAnalysis = {
        price: getSimulatedPrice(pair),
        volatility: Math.random() * 100,
        volume: Math.random() * 10000 + 1000,
        trend: Math.random() > 0.5 ? 'صاعد' : 'هابط',
        momentum: Math.random() * 100 - 50,
        rsi: Math.random() * 100,
        macd: Math.random() > 0.5 ? 'إيجابي' : 'سلبي',
        supportLevel: getSimulatedPrice(pair) * 0.95,
        resistanceLevel: getSimulatedPrice(pair) * 1.05,
        score: Math.random() * 100 // درجة جاذبية الزوج للتداول
      };
      
      // تحليل الاستراتيجيات المناسبة لهذا الزوج
      const strategyAnalysis: Record<string, number> = {};
      
      for (const strategy of strategies) {
        // تقييم ملاءمة كل استراتيجية لهذا الزوج في ظروف السوق الحالية
        let score = 0;
        
        switch (strategy) {
          case 'trend_following':
            // استراتيجية تتبع الاتجاه تعمل بشكل أفضل مع الأزواج ذات الاتجاه القوي
            score = pairAnalysis.trend === 'صاعد' ? 
              20 + pairAnalysis.momentum * 0.5 : 
              10 + Math.abs(pairAnalysis.momentum) * 0.3;
            break;
            
          case 'mean_reversion':
            // استراتيجية الارتداد المتوسط تعمل بشكل أفضل عندما يكون السعر متطرفًا
            score = pairAnalysis.rsi > 70 || pairAnalysis.rsi < 30 ? 
              80 + (pairAnalysis.volatility * 0.2) : 
              30 + (pairAnalysis.volatility * 0.1);
            break;
            
          case 'breakout':
            // استراتيجية الاختراق تعمل بشكل أفضل مع الأزواج ذات الحجم المرتفع
            score = pairAnalysis.volume > 5000 ? 
              60 + (pairAnalysis.volume * 0.01) : 
              20 + (pairAnalysis.volume * 0.005);
            break;
            
          case 'scalping':
            // استراتيجية المضاربة السريعة تعمل بشكل أفضل مع الأزواج ذات التقلب العالي
            score = pairAnalysis.volatility > 50 ? 
              70 + (pairAnalysis.volatility * 0.3) : 
              40 + (pairAnalysis.volatility * 0.1);
            break;
            
          default:
            score = 50; // درجة متوسطة للاستراتيجيات غير المعروفة
        }
        
        strategyAnalysis[strategy] = Math.min(100, Math.max(0, score));
      }
      
      // إضافة تحليل الاستراتيجيات إلى نتيجة الزوج
      result[pair] = {
        ...pairAnalysis,
        strategies: strategyAnalysis,
        recommendedStrategy: Object.keys(strategyAnalysis).reduce((best, strategy) => {
          return strategyAnalysis[strategy] > strategyAnalysis[best] ? strategy : best;
        }, Object.keys(strategyAnalysis)[0])
      };
    }
    
    return result;
  } catch (error) {
    console.error('Error analyzing market conditions:', error);
    return {};
  }
}

// Function to recommend the best strategy
async function recommendBestStrategy(strategies: string[], pair: string, riskLevel: string) {
  try {
    // في بيئة حقيقية، هذه الدالة ستحلل البيانات التاريخية والحالية
    // لتحديد أفضل استراتيجية للزوج المحدد
    
    // محاكاة اختيار الاستراتيجية
    const strategyScores: Record<string, number> = {};
    
    for (const strategy of strategies) {
      // تقييم كل استراتيجية بناءً على عوامل مختلفة
      let score = Math.random() * 100;
      
      // تعديل النتيجة بناءً على مستوى المخاطرة
      if (riskLevel === 'low') {
        // تفضيل استراتيجيات أقل مخاطرة للمستوى المنخفض
        if (strategy === 'mean_reversion') score += 20;
        if (strategy === 'scalping') score -= 10;
      } else if (riskLevel === 'high') {
        // تفضيل استراتيجيات أكثر مخاطرة للمستوى العالي
        if (strategy === 'breakout') score += 20;
        if (strategy === 'scalping') score += 15;
      }
      
      strategyScores[strategy] = score;
    }
    
    // تحديد أفضل استراتيجية
    const bestStrategy = Object.keys(strategyScores).reduce((best, strategy) => {
      return strategyScores[strategy] > strategyScores[best] ? strategy : best;
    }, strategies[0]);
    
    // تحديد اتجاه التداول (شراء/بيع)
    const direction = Math.random() > 0.5 ? 'buy' : 'sell';
    
    // ترجمة أسماء الاستراتيجيات
    const strategyNames: Record<string, string> = {
      'trend_following': 'تتبع الاتجاه',
      'mean_reversion': 'الارتداد المتوسط',
      'breakout': 'الاختراق',
      'scalping': 'المضاربة السريعة',
      'smart_auto': 'الإدارة الذكية'
    };
    
    return {
      strategy: bestStrategy,
      strategyName: strategyNames[bestStrategy] || bestStrategy,
      pair: pair,
      direction: direction,
      confidence: strategyScores[bestStrategy] / 100,
      riskLevel: riskLevel,
      recommendedSettings: {
        stopLossPercent: riskLevel === 'low' ? 1 : riskLevel === 'medium' ? 2 : 3,
        takeProfitPercent: riskLevel === 'low' ? 3 : riskLevel === 'medium' ? 5 : 8,
      }
    };
  } catch (error) {
    console.error('Error recommending strategy:', error);
    return {
      strategy: strategies[0],
      strategyName: 'الافتراضية',
      pair: pair,
      direction: 'buy',
      confidence: 0.5,
      riskLevel: riskLevel
    };
  }
}

// Function to calculate position size
function calculatePositionSize(balance: number, riskPercentage: number, symbol: string, smartSizing: boolean = false) {
  try {
    // الحد الأقصى للمبلغ المعرض للخطر
    const maxRiskAmount = balance * (riskPercentage / 100);
    
    // محاكاة سعر الزوج
    const price = getSimulatedPrice(symbol);
    
    // حساب الحجم الأساسي
    let baseSize = maxRiskAmount / price;
    
    // إذا كان التحجيم الذكي مفعلاً، قم بتعديل الحجم بناءً على عوامل إضافية
    if (smartSizing) {
      // محاكاة تقلب السوق (0-1)
      const volatility = Math.random();
      
      // تعديل الحجم بناءً على التقلب (خفض الحجم في الأسواق شديدة التقلب)
      const volatilityFactor = 1 - (volatility * 0.5);
      
      // محاكاة قوة الاتجاه (0-1)
      const trendStrength = Math.random();
      
      // زيادة الحجم قليلاً للاتجاهات القوية
      const trendFactor = 1 + (trendStrength * 0.2);
      
      // تطبيق العوامل
      baseSize = baseSize * volatilityFactor * trendFactor;
    }
    
    // تقريب الحجم إلى عدد مناسب من المنازل العشرية حسب الزوج
    if (symbol.includes('BTC')) {
      return Math.max(0.001, parseFloat(baseSize.toFixed(3)));
    } else if (symbol.includes('ETH')) {
      return Math.max(0.01, parseFloat(baseSize.toFixed(2)));
    } else {
      return Math.max(1, parseFloat(baseSize.toFixed(0)));
    }
  } catch (error) {
    console.error('Error calculating position size:', error);
    // حجم افتراضي صغير للأمان
    return 0.01;
  }
}

// Function to execute a trade with support for auto-trading
async function executeTrade(
  apiKey: string,
  apiSecret: string,
  symbol: string,
  type: string,
  lotSize: number,
  stopLoss: number | null,
  takeProfit: number | null,
  accountId: string,
  supabase: any,
  botId?: string,
  isAutoTrade: boolean = false,
  strategyUsed: string = ''
) {
  try {
    // Log the trade attempt
    await supabase.from('trading_logs').insert({
      bot_id: botId,
      account_id: accountId,
      log_type: 'info',
      message: `Executing ${type} order for ${symbol}`,
      details: { 
        symbol,
        type,
        lot_size: lotSize,
        stop_loss: stopLoss,
        take_profit: takeProfit,
        timestamp: new Date().toISOString(),
        auto_trade: isAutoTrade,
        strategy_used: strategyUsed
      }
    })
    
    // Get current price for the symbol (simulated)
    const currentPrice = await getSimulatedPrice(symbol)
    
    // في حالة التداول التلقائي، نقوم بحساب قيم وقف الخسارة وجني الربح تلقائيًا
    let calculatedStopLoss = stopLoss;
    let calculatedTakeProfit = takeProfit;
    
    if (isAutoTrade) {
      // حساب قيم وقف الخسارة وجني الربح بناءً على استراتيجية التداول
      if (type === 'buy') {
        calculatedStopLoss = currentPrice * 0.98; // 2% أقل من سعر الدخول
        calculatedTakeProfit = currentPrice * 1.04; // 4% أعلى من سعر الدخول
      } else {
        calculatedStopLoss = currentPrice * 1.02; // 2% أعلى من سعر الدخول
        calculatedTakeProfit = currentPrice * 0.96; // 4% أقل من سعر الدخول
      }
    }
    
    // Create a new trade record
    const { data: tradeData, error: tradeError } = await supabase
      .from('trades')
      .insert({
        account_id: accountId,
        bot_id: botId,
        symbol,
        type,
        entry_price: currentPrice,
        lot_size: lotSize,
        stop_loss: calculatedStopLoss,
        take_profit: calculatedTakeProfit,
        status: 'open',
        metadata: isAutoTrade ? {
          auto_trade: true,
          strategy_used: strategyUsed,
          auto_sized: true
        } : undefined
      })
      .select()
      
    if (tradeError) {
      throw new Error(`Error recording trade: ${tradeError.message}`)
    }
    
    // Log successful trade
    await supabase.from('trading_logs').insert({
      bot_id: botId,
      account_id: accountId,
      log_type: 'success',
      message: `Successfully placed ${type} order for ${symbol}`,
      details: { 
        trade_id: tradeData[0].id,
        price: currentPrice,
        timestamp: new Date().toISOString(),
        auto_trade: isAutoTrade,
        strategy_used: strategyUsed
      }
    })
    
    return { 
      success: true, 
      trade_id: tradeData[0].id,
      message: `Successfully executed ${type} order for ${symbol} at price ${currentPrice}`,
      price: currentPrice,
      auto_trade: isAutoTrade
    }
  } catch (error) {
    console.error(`Error executing trade:`, error.message)
    return { success: false, error: error.message }
  }
}

// Helper function to get simulated price
async function getSimulatedPrice(symbol: string): Promise<number> {
  try {
    // In a real implementation, this would fetch the current market price
    // For demo purposes, we'll use mock prices
    const mockPrices: Record<string, number> = {
      'BTCUSDT': 29850.75,
      'ETHUSDT': 1865.25,
      'BNBUSDT': 221.45,
      'XRPUSDT': 0.52,
      'ADAUSDT': 0.35,
      'DOGEUSDT': 0.078,
      'SOLUSDT': 140.25,
      'MATICUSDT': 0.58
    }
    
    return mockPrices[symbol] || 100.0
  } catch (error) {
    console.error(`Error getting price:`, error)
    return 100.0 // Default fallback price
  }
}

serve(handler)
